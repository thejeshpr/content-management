# Model Context Protocol (MCP) vs Function Calling vs OpenAPI Tools — When to Use Each?

**By Michal Sutter — October 8, 2025**

## Table of Contents

1. Comparison Table  
2. Strengths and Limits  
3. Security and Governance  
4. Ecosystem Signals (Portability / Adoption)  
5. Decision Rules (When to Use Which)  
6. References  

---

## Introduction / Overview

- **MCP (Model Context Protocol):** An open, transport-agnostic protocol that standardizes how tools, resources, and prompts are discovered and invoked across hosts and servers. Ideal for portable, multi-tool, multi-runtime systems.  
- **Function Calling:** A vendor feature where the model picks a declared function (described via JSON Schema), returns the arguments, and your runtime executes that function. Best suited to single-application, low-latency integrations.  
- **OpenAPI Tools:** Use the OpenAPI Specification (OAS) 3.1 as a contract for HTTP services; tooling layers (e.g. agent frameworks) auto-generate callable tools. Best where you have well-governed HTTP services, service meshes, and contract-driven architectures.

---

## 1. Comparison Table

| Concern             | MCP                            | Function Calling                                | OpenAPI Tools                                    |
|---------------------|--------------------------------|--------------------------------------------------|---------------------------------------------------|
| **Interface contract** | Protocol data model (tools / resources / prompts) | Per-function JSON Schema                          | OAS 3.1 document                                   |
| **Discovery**         | Dynamic via `tools/list`       | Static list provided to the model                 | From OAS; catalogable                              |
| **Invocation**        | `tools/call` over JSON-RPC session | Model selects function; app executes HTTP request per OAS operation | Agent/tooling routes intents → operations         |
| **Orchestration**     | Host routes across many servers/tools | Application-local chaining                         | Agent/toolkit handles routing via OAS operations   |
| **Transport**          | stdio / HTTP variants          | In-band via LLM API                               | HTTP(S) to services                                |
| **Portability**        | Cross-host/server              | Vendor-specific interface                         | Vendor-neutral contracts (HTTP-based)             |

---

## 2. Strengths and Limits

### **MCP**

**Strengths:**
- Standardized discovery and invocation across tools and servers  
- Enables multi-tool orchestration  
- Host support is growing (e.g. Semantic Kernel, Cursor; plans for Windows integration)  

**Limits:**
- You must operate servers and enforce host policy (identity, consent, sandboxing)  
- The host must manage session lifecycle and routing  

### **Function Calling**

**Strengths:**
- Minimal integration overhead  
- Fast feedback / control loop  
- JSON Schema-based validation is straightforward  

**Limits:**
- Catalog is local to the app  
- To be portable across vendors, you must re-define schemas per vendor  
- Limited built-in discovery and governance  

### **OpenAPI Tools**

**Strengths:**
- Mature contract-based design  
- Built-in security schemes (OAuth2, API keys)  
- Rich tooling ecosystems (e.g. auto-generation from OAS)  

**Limits:**
- OAS alone does *not* define the agent control loop — you still need an orchestrator or host  
- HTTP contracts may be limiting in more complex routing / multi-host contexts  

---

## 3. Security and Governance

- **MCP:** Enforce host-side policies (which servers are allowed, user consent), per-tool scopes, ephemeral credentials. Platforms like Windows may adopt registry-level control and consent prompts.  
- **Function Calling:** Validate the arguments generated by the model against schemas; maintain allowlists; log all function calls for audit trails.  
- **OpenAPI Tools:** Leverage OAS security schemes; use gateways and schema validation to constrain tool usage; restrict agent toolkits from making arbitrary requests.

---

## 4. Ecosystem Signals (Portability / Adoption)

- **MCP:** Supported in Microsoft’s Semantic Kernel (as both host and server) and in Cursor (which provides an MCP directory plus IDE integration). Microsoft has also signaled intent for system-level support on Windows.  
- **Function Calling:** Broadly available across major LLM APIs (OpenAI, Anthropic, etc.) following similar patterns (schema + selection + tool execution).  
- **OpenAPI Tools:** Many agent frameworks automatically generate tools from OAS (e.g. in LangChain for Python/JavaScript).  

---

## 5. Decision Rules (When to Use Which)

1. **Function Calling**  
   Use when you have app-local automations, a small number of actions, and tight latency requirements. Keep definitions minimal, validate strictly, and thoroughly unit-test the loop.

2. **MCP**  
   Choose this when you want cross-runtime portability and shared integrations (e.g. agents, desktop clients, backend services). MCP’s standardized discovery and invocation make reuse and integration easier.

3. **OpenAPI Tools**  
   Best in enterprises where you already have HTTP services, contracts, security, and governance. Use OAS as your source of truth, generate tools from it, and rely on an orchestrator to mediate.

4. **Hybrid / Mixed Pattern**  
   A common real-world architecture: maintain OAS for your HTTP services, *and* expose those services via an MCP server (for portability), or export a subset as function calls for latency-sensitive surfaces.

---

## 6. References

- **MCP (Model Context Protocol)**  
  - https://modelcontextprotocol.io/  
  - https://www.anthropic.com/news/model-context-protocol  
  - https://modelcontextprotocol.io/docs/concepts/tools  
  - https://modelcontextprotocol.io/legacy/concepts/tools  
  - https://github.com/modelcontextprotocol  
  - https://developers.openai.com/apps-sdk/concepts/mcp-server  
  - https://devblogs.microsoft.com/semantic-kernel/semantic-kernel-adds-model-context-protocol-mcp-support-for-python  
  - https://devblogs.microsoft.com/semantic-kernel/integrating-model-context-protocol-tools-with-semantic-kernel-a-step-by-step-guide  
  - https://cursor.com/docs/context/mcp  
  - https://learn.microsoft.com/en-us/semantic-kernel/concepts/kernel  

- **Function Calling (LLM tool-calling features)**  
  - https://platform.openai.com/docs/guides/function-calling  
  - https://platform.openai.com/docs/assistants/tools/function-calling  
  - https://help.openai.com/en/articles/8555517-function-calling-in-the-openai-api  
  - https://docs.anthropic.com/en/docs/build-with-claude/tool-use  
  - https://docs.claude.com/en/docs/agents-and-tools/tool-use/overview  
  - https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters-anthropic-claude-messages-tool-use.html  

- **OpenAPI (spec + LLM toolchains)**  
  - https://spec.openapis.org/oas/v3.1.0.html  
  - https://swagger.io/specification/  
  - https://www.openapis.org/blog/2021/02/18/openapi-specification-3-1-released  
  - https://python.langchain.com/docs/integrations/tools/openapi/  
  - https://python.langchain.com/api_reference/community/agent_toolkits/langchain_community.agent_toolkits.openapi.toolkit.OpenAPIToolkit.html  
  - https://docs.langchain.com/oss/javascript/integrations/tools/openapi  
  - https://js.langchain.com/docs/integrations/toolkits/openapi